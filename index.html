<!DOCTYPE html>
<html>
  <head>
    <title>Lunar GVT VR Experience</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
    <meta name="mobile-web-app-capable" content="yes">
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      html, body { 
        margin: 0; 
        padding: 0;
        overflow: hidden; 
        width: 100vw; 
        height: 100vh;
        position: fixed;
        touch-action: none;
        -webkit-user-select: none;
        user-select: none;
      }
      #ui-overlay {
        position: fixed; 
        top: env(safe-area-inset-top, 20px); 
        left: env(safe-area-inset-left, 20px);
        color: white; 
        font-family: Arial; 
        z-index: 1000;
        pointer-events: none;
        font-size: 12px;
        text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        max-width: 180px;
      }
      
      @media (max-width: 768px) {
        #ui-overlay {
          font-size: 10px;
          max-width: 150px;
        }
      }
      
      /* Fullscreen button */
      #fullscreen-btn {
        position: fixed;
        bottom: env(safe-area-inset-bottom, 20px);
        left: env(safe-area-inset-left, 20px);
        z-index: 1000;
        padding: 12px 16px;
        background: rgba(0,0,0,0.7);
        color: #fff;
        border: 1px solid rgba(255,255,255,0.2);
        border-radius: 8px;
        font-family: Arial, sans-serif;
        font-size: 14px;
        cursor: pointer;
        box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        backdrop-filter: blur(10px);
      }
      #fullscreen-btn:active {
        background: rgba(0,0,0,0.9);
      }
      /* DOM iframe that will be positioned to visually sit on the wall plane */
      #wall-iframe {
        position: absolute;
        left: 0; top: 0;
        width: 0; height: 0;
        border: 3px solid rgba(255,255,255,0.95);
        border-radius: 6px;
        box-shadow: 0 8px 30px rgba(0,0,0,0.6);
        z-index: 2000; /* above the A-Frame canvas */
        background: #000;
        transform-origin: 50% 50%;
        transition: transform 120ms linear, width 120ms linear, height 120ms linear, left 120ms linear, top 120ms linear;
        will-change: transform, left, top, width, height;
        touch-action: manipulation;
      }
      #wall-iframe.hidden { display: none; }

      /* Mobile-friendly open button shown when iframe is too small or on touch devices */
      #open-site-btn {
        position: absolute; z-index: 2100; display: inline-flex; align-items: center; justify-content: center;
        padding: 10px 14px; background: rgba(0,0,0,0.7); color: #fff; border-radius: 8px; border: 1px solid rgba(255,255,255,0.12);
        font-family: Arial, sans-serif; font-size: 15px; box-shadow: 0 6px 20px rgba(0,0,0,0.4);
      }
      #open-site-btn.hidden { display: none; }

      /* Mobile joystick UI */
      #joystick {
        position: fixed;
        left: env(safe-area-inset-left, 18px);
        bottom: calc(env(safe-area-inset-bottom, 18px) + 80px);
        width: 120px;
        height: 120px;
        border-radius: 50%;
        background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.06), rgba(0,0,0,0.02));
        display: none; /* shown on touch devices via JS */
        align-items: center;
        justify-content: center;
        z-index: 3000;
        touch-action: none;
        -webkit-tap-highlight-color: transparent;
      }
      #joystick .stick {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: rgba(255,255,255,0.18);
        box-shadow: 0 6px 18px rgba(0,0,0,0.4);
        transform: translate(0px,0px);
        transition: transform 80ms linear;
      }
      /* Hide joystick on large screens where keyboard is preferred */
      @media (min-width: 900px){ #joystick { display: none !important; } }
    </style>
  </head>
  <body>
    <!-- Fullscreen button -->
    <button id="fullscreen-btn">â›¶ Fullscreen</button>
    
    <!-- Overlay -->
    <div id="ui-overlay">
      ðŸŒŒ LUNAR GVT VR EXPERIENCE <br>
      WASD / Arrows = Move â€¢ Mouse = Look â€¢ VR Ready
    </div>

    <a-scene vr-mode-ui="enabled: true">
      <!-- Immersive space environment -->
      <a-sky color="#0a0a1a"></a-sky>
      
      <!-- Ambient stars -->
      <a-entity position="0 0 0">
        <a-sphere position="5 3 -8" radius="0.05" color="#ffffff" opacity="0.8"></a-sphere>
        <a-sphere position="-4 5 -12" radius="0.04" color="#ffffff" opacity="0.7"></a-sphere>
        <a-sphere position="8 -2 -15" radius="0.06" color="#ffffff" opacity="0.9"></a-sphere>
        <a-sphere position="-7 4 -10" radius="0.03" color="#ffffff" opacity="0.6"></a-sphere>
        <a-sphere position="3 -3 -20" radius="0.05" color="#ffffff" opacity="0.8"></a-sphere>
      </a-entity>

      <!-- Ambient lighting for VR -->
      <a-light type="ambient" color="#6080a0" intensity="0.5"></a-light>
      <a-light type="directional" position="1 1 0" intensity="0.3" color="#ffffff"></a-light>

      <!-- Camera with VR support -->
      <a-entity camera look-controls wasd-controls position="0 1.6 0"></a-entity>
    </a-scene>

    <!-- Floating interactive screen in VR space - Larger for mobile -->
    <a-plane id="wall-screen" position="0 1.6 -2.5" rotation="0 0 0" width="5" height="2.8" color="#000"
      material="shader: flat; opacity: 1">
    </a-plane>

    <script>
      // Fullscreen functionality
      const fullscreenBtn = document.getElementById('fullscreen-btn');
      
      function toggleFullscreen() {
        if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement) {
          // Enter fullscreen
          const elem = document.documentElement;
          if (elem.requestFullscreen) {
            elem.requestFullscreen();
          } else if (elem.webkitRequestFullscreen) { // Safari
            elem.webkitRequestFullscreen();
          } else if (elem.mozRequestFullScreen) { // Firefox
            elem.mozRequestFullScreen();
          } else if (elem.msRequestFullscreen) { // IE/Edge
            elem.msRequestFullscreen();
          }
          fullscreenBtn.textContent = 'â›¶ Exit Fullscreen';
        } else {
          // Exit fullscreen
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          }
          fullscreenBtn.textContent = 'â›¶ Fullscreen';
        }
      }
      
      fullscreenBtn.addEventListener('click', toggleFullscreen);
      
      // Update button text on fullscreen change
      document.addEventListener('fullscreenchange', () => {
        fullscreenBtn.textContent = document.fullscreenElement ? 'â›¶ Exit Fullscreen' : 'â›¶ Fullscreen';
      });
      document.addEventListener('webkitfullscreenchange', () => {
        fullscreenBtn.textContent = document.webkitFullscreenElement ? 'â›¶ Exit Fullscreen' : 'â›¶ Fullscreen';
      });
      
      // Auto-enter fullscreen on mobile when user interacts
      let autoFullscreenTriggered = false;
      function tryAutoFullscreen() {
        if (!autoFullscreenTriggered && window.innerWidth < 900) {
          autoFullscreenTriggered = true;
          toggleFullscreen();
        }
      }
      
      // Trigger on first touch or click
      document.addEventListener('touchstart', tryAutoFullscreen, { once: true });
      document.addEventListener('click', tryAutoFullscreen, { once: true });
    </script>

    <script>
      (function(){
        const URL = 'https://lunargvt.vercel.app/';
        // Create iframe element that will be positioned over the plane
        const iframe = document.createElement('iframe');
        iframe.id = 'wall-iframe';
        iframe.src = URL;
        iframe.title = 'Lunar GVT on wall';
        // Allow typical interactions; if framing blocked the iframe will be empty/blocked
        iframe.sandbox = 'allow-forms allow-scripts allow-same-origin allow-popups';
        document.body.appendChild(iframe);
        
        // Create mobile-friendly open button (used when iframe is too small or on touch devices)
        const openBtn = document.createElement('button');
        openBtn.id = 'open-site-btn';
        openBtn.innerText = 'Open site';
        openBtn.className = 'hidden';
        document.body.appendChild(openBtn);
        openBtn.addEventListener('click', ()=> window.open(URL, '_blank'));

        const sceneEl = document.querySelector('a-scene');
        const planeEl = document.getElementById('wall-screen');
        const cameraEl = document.querySelector('[camera]');

        // Fallback: clicking the plane (or iframe) opens the URL in a new tab
        function openInTab(){ window.open(URL, '_blank'); }
        planeEl.addEventListener('click', openInTab);
        iframe.addEventListener('click', (e)=>{ e.stopPropagation(); });

        // Project 3D plane corners to 2D screen coordinates and size the iframe accordingly
        function updateIframePosition(){
          const threeCam = cameraEl && (cameraEl.getObject3D('camera') || cameraEl.object3D.children.find(c=>c.isCamera));
          if(!threeCam) return;
          const planeObj = planeEl.object3D;

          const halfWidth = parseFloat(planeEl.getAttribute('width'))/2;
          const halfHeight = parseFloat(planeEl.getAttribute('height'))/2;

          // Define the four corners in local space
          const cornersLocal = [
            new THREE.Vector3(-halfWidth, -halfHeight, 0),
            new THREE.Vector3(halfWidth, -halfHeight, 0),
            new THREE.Vector3(halfWidth, halfHeight, 0),
            new THREE.Vector3(-halfWidth, halfHeight, 0)
          ];

          const projected = cornersLocal.map(v=>{
            const world = v.clone();
            planeObj.localToWorld(world);
            const ndc = world.clone().project(threeCam);
            return { world, ndc };
          });

          // If all corners are behind the camera (z > 1), hide
          const allBehind = projected.every(p => p.ndc.z > 1);
          if(allBehind){
            iframe.classList.add('hidden');
            return;
          }
          iframe.classList.remove('hidden');

          // Convert NDC to screen coords
          const points = projected.map(p => ({
            x: (p.ndc.x * 0.5 + 0.5) * window.innerWidth,
            y: (-p.ndc.y * 0.5 + 0.5) * window.innerHeight
          }));

          // Bounding rect of projected corners
          const xs = points.map(pt => pt.x);
          const ys = points.map(pt => pt.y);
          const minX = Math.min(...xs);
          const maxX = Math.max(...xs);
          const minY = Math.min(...ys);
          const maxY = Math.max(...ys);

          // Use devicePixelRatio to help crispness and scale on mobile
          const dpr = window.devicePixelRatio || 1;
          let width = Math.max(1, Math.round((maxX - minX)));
          let height = Math.max(1, Math.round((maxY - minY)));
          const left = Math.round(minX);
          const top = Math.round(minY);

          // Keep a sensible minimum so the iframe remains usable when very far away
          // Minimum usable size; scale slightly larger on touch devices
          const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
          const minW = isTouch ? 200 : 120;
          const minH = Math.round(minW * 9 / 16);
          if(width < minW){
            // expand around center
            const cx = left + width/2;
            width = minW;
            const newLeft = Math.round(cx - width/2);
            iframe.style.left = newLeft + 'px';
            iframe.style.width = width + 'px';
          } else {
            iframe.style.left = left + 'px';
            iframe.style.width = width + 'px';
          }

          if(height < minH){
            const cy = top + height/2;
            height = Math.round(minH);
            const newTop = Math.round(cy - height/2);
            iframe.style.top = newTop + 'px';
            iframe.style.height = height + 'px';
          } else {
            iframe.style.top = top + 'px';
            iframe.style.height = height + 'px';
          }

          // Compute plane rotation relative to camera and apply CSS rotate transforms for better visual alignment
          try{
            const planeQ = planeObj.getWorldQuaternion(new THREE.Quaternion());
            const camQ = threeCam.quaternion.clone();
            const rel = camQ.clone().inverse().multiply(planeQ);
            const e = new THREE.Euler().setFromQuaternion(rel, 'YXZ');
            // Convert to degrees and invert x because CSS rotateX positive is downwards
            const rotY = THREE.MathUtils.radToDeg(e.y);
            const rotX = -THREE.MathUtils.radToDeg(e.x);
            const rotZ = THREE.MathUtils.radToDeg(e.z);
            // Apply CSS perspective + rotations (small perspective to hint depth)
            const perspective = Math.min(1200, Math.max(600, 800 * dpr));
            iframe.style.transform = `perspective(${perspective}px) rotateX(${rotX}deg) rotateY(${rotY}deg) rotateZ(${rotZ}deg)`;
          }catch(err){
            // ignore if three.js not available yet
          }

          // Mobile fallback: if small or touch device, hide iframe interaction and show open button
          if(width < (isTouch ? 320 : 120) || height < (isTouch ? 180 : 80)){
            iframe.style.pointerEvents = 'none';
            openBtn.classList.remove('hidden');
            openBtn.style.left = (left + Math.max(0, width - openBtn.offsetWidth)/2) + 'px';
            openBtn.style.top = (top + Math.max(0, height - openBtn.offsetHeight)/2) + 'px';
          } else {
            iframe.style.pointerEvents = 'auto';
            openBtn.classList.add('hidden');
          }
        }

        // Update on each frame
        function tick(){ updateIframePosition(); requestAnimationFrame(tick); }
        // Begin once three.js is available
        requestAnimationFrame(tick);

        // Handle resize
        window.addEventListener('resize', updateIframePosition);

        // If the iframe fails to load due to X-Frame-Options/CSP, the user can still click the plane to open the URL.
      })();
    </script>

    <!-- Mobile joystick DOM and behavior -->
    <div id="joystick" aria-hidden="true">
      <div class="stick" id="joystick-stick"></div>
    </div>
    <script>
      (function(){
        const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const joystick = document.getElementById('joystick');
        const stick = document.getElementById('joystick-stick');
        const cameraEl = document.querySelector('[camera]');

        if(!isTouch || !joystick || !cameraEl){
          // Nothing to do on non-touch devices
          return;
        }

        // Show joystick on touch devices
        joystick.style.display = 'flex';

        let dragging = false;
        const maxRadius = 40; // px
        let startX = 0, startY = 0;

        function setStick(x,y){
          stick.style.transform = `translate(${x}px, ${y}px)`;
        }

        function onStart(e){
          dragging = true;
          const touch = e.touches ? e.touches[0] : e;
          const rect = joystick.getBoundingClientRect();
          startX = rect.left + rect.width/2;
          startY = rect.top + rect.height/2;
          updateFromPos(touch.clientX, touch.clientY);
          if (e.cancelable) e.preventDefault();
        }

        function onMove(e){
          if(!dragging) return;
          const touch = e.touches ? e.touches[0] : e;
          updateFromPos(touch.clientX, touch.clientY);
          if (e.cancelable) e.preventDefault();
        }

        function onEnd(e){
          dragging = false;
          setStick(0,0);
        }

        let lastVX = 0, lastVY = 0;
        function updateFromPos(cx, cy){
          let dx = cx - startX;
          let dy = cy - startY;
          const dist = Math.hypot(dx, dy);
          if(dist > maxRadius){ dx = dx / dist * maxRadius; dy = dy / dist * maxRadius; }
          setStick(dx, dy);
          // Normalize to [-1,1]
          const nx = dx / maxRadius;
          const ny = dy / maxRadius;
          lastVX = nx; lastVY = ny;
        }

        joystick.addEventListener('touchstart', onStart, { passive: false });
        joystick.addEventListener('touchmove', onMove, { passive: false });
        joystick.addEventListener('touchend', onEnd);
        joystick.addEventListener('touchcancel', onEnd);
        // Also support mouse for quick testing
        joystick.addEventListener('mousedown', (e)=>{ onStart(e); window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', ()=>{ onEnd(); window.removeEventListener('mousemove', onMove); }); });

        // Movement loop: apply walk vector based on joystick input to the camera
        const speed = 2.0; // meters per second at full tilt
        let prev = performance.now();
        function moveTick(now){
          const dt = Math.min(0.1, (now - prev) / 1000);
          prev = now;
          // read lastVX, lastVY
          const vx = lastVX; // right positive
          const vy = -lastVY; // forward positive (invert Y so pushing up moves forward)
          if(Math.abs(vx) > 0.01 || Math.abs(vy) > 0.01){
            // Compute direction relative to camera yaw only
            const camObj = cameraEl.object3D;
            const euler = new THREE.Euler().setFromQuaternion(camObj.quaternion, 'YXZ');
            const yaw = euler.y;
            // Forward vector
            const forward = new THREE.Vector3(Math.sin(yaw), 0, -Math.cos(yaw));
            const right = new THREE.Vector3(Math.cos(yaw), 0, Math.sin(yaw));
            const move = new THREE.Vector3();
            move.addScaledVector(forward, vy * speed * dt);
            move.addScaledVector(right, vx * speed * dt);
            cameraEl.object3D.position.add(move);
          }
          requestAnimationFrame(moveTick);
        }
        requestAnimationFrame(moveTick);
      })();
    </script>
  </body>
</html>